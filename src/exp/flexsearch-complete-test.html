<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Complete FlexSearch Test & Performance Comparison</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 1200px;
        margin: 20px auto;
        padding: 20px;
        line-height: 1.6;
      }

      .test-section {
        margin: 20px 0;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #f8f9fa;
      }

      .status {
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        font-weight: 500;
      }

      .status.loading {
        background: #fff3cd;
        color: #856404;
      }
      .status.ready {
        background: #d4edda;
        color: #155724;
      }
      .status.error {
        background: #f8d7da;
        color: #721c24;
      }

      .results {
        background: #fff;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 15px;
        margin: 10px 0;
        max-height: 400px;
        overflow-y: auto;
        font-family: 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        white-space: pre-line;
      }

      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
        font-size: 16px;
      }

      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .performance-summary {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
      }

      .metric {
        background: white;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #dee2e6;
      }

      .metric h3 {
        margin: 0 0 10px 0;
        color: #495057;
      }

      .metric .value {
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
      }

      .winner {
        border: 2px solid #28a745;
        background: #d4edda;
      }

      .debug-logs {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <h1>üß™ Complete FlexSearch Test & Performance Comparison</h1>

    <!-- Debug Section -->
    <div class="test-section">
      <h2>üîç Debug Tests</h2>
      <button onclick="runDebugTests()">Run Debug Tests</button>
      <div id="debug-status" class="status loading">Ready to test...</div>
      <div id="debug-logs" class="debug-logs">
        Click "Run Debug Tests" to check:
      </div>
    </div>

    <!-- FlexSearch Status -->
    <div class="test-section">
      <h2>‚ö° FlexSearch + Web Worker Status</h2>
      <div id="flexsearch-status" class="status loading">Not started</div>
      <button id="start-flexsearch" onclick="startFlexSearch()">
        Start FlexSearch Loading
      </button>
      <button
        id="restart-flexsearch"
        onclick="restartFlexSearch()"
        style="display: none"
      >
        üîÑ Restart FlexSearch
      </button>
    </div>

    <!-- Performance Tests -->
    <div class="test-section">
      <h2>üèÅ Performance Test Controls</h2>
      <button onclick="testVercel()">Test Vercel Blob Performance</button>
      <button id="test-flexsearch" onclick="testFlexSearch()" disabled>
        Test FlexSearch Performance
      </button>
      <button id="run-comparison" onclick="runFullComparison()" disabled>
        üèÜ Run Head-to-Head Comparison
      </button>
    </div>

    <!-- Performance Summary -->
    <div class="performance-summary">
      <div class="metric" id="vercel-metric">
        <h3>üåê Vercel Blob</h3>
        <div class="value" id="vercel-time">--</div>
        <div>Average response time</div>
      </div>
      <div class="metric" id="flexsearch-metric">
        <h3>‚ö° FlexSearch + Worker</h3>
        <div class="value" id="flexsearch-time">--</div>
        <div>Average search time</div>
      </div>
    </div>

    <!-- Test Results -->
    <div class="test-section">
      <h2>üìä Test Results</h2>
      <div id="test-results" class="results">
        Click any test button to see results...
      </div>
    </div>

    <script type="module">
      // Global state
      let flexSearchWorker = null;
      let flexSearchReady = false;
      let workerBlobUrl = null;

      const TEST_QUERIES = ['123', '456', '789', 'main', 'oak'];
      const FLEXSEARCH_INDEX_URL =
        'https://firebasestorage.googleapis.com/v0/b/land-estimator-29ee9.firebasestorage.app/o/cdn%2Fflexsearch-index.json.gz?alt=media';

      // Debug logging
      function debugLog(message) {
        console.log(message);
        const logsDiv = document.getElementById('debug-logs');
        logsDiv.innerHTML += message + '\n';
        logsDiv.scrollTop = logsDiv.scrollHeight;
      }

      // Update status displays
      function updateStatus(elementId, status, message) {
        const el = document.getElementById(elementId);
        el.textContent = message;
        el.className = `status ${status}`;
      }

      // Debug Tests
      window.runDebugTests = async function () {
        const logsDiv = document.getElementById('debug-logs');
        logsDiv.innerHTML = '';

        updateStatus('debug-status', 'loading', 'Running debug tests...');

        try {
          // Test 1: Firebase Storage fetch
          debugLog('1. Testing Firebase Storage fetch...');
          debugLog(`   URL: ${FLEXSEARCH_INDEX_URL}`);

          let response;
          try {
            // Try multiple approaches to handle potential CORS issues
            let fetchSuccess = false;

            // Attempt 1: Simple fetch (usually works for public Firebase Storage)
            debugLog('   Attempt 1: Simple fetch...');
            try {
              response = await fetch(FLEXSEARCH_INDEX_URL, {
                method: 'GET',
                cache: 'no-cache'
              });

              debugLog(`   Status: ${response.status} ${response.statusText}`);
              debugLog(
                `   Content-Type: ${response.headers.get('content-type')}`
              );
              debugLog(
                `   Content-Length: ${response.headers.get('content-length')}`
              );
              debugLog(
                `   Access-Control-Allow-Origin: ${response.headers.get('access-control-allow-origin')}`
              );

              if (response.ok) {
                fetchSuccess = true;
                debugLog('   ‚úÖ Simple fetch successful');
              } else {
                throw new Error(
                  `HTTP ${response.status}: ${response.statusText}`
                );
              }
            } catch (simpleError) {
              debugLog(`   ‚ùå Simple fetch failed: ${simpleError.message}`);
              debugLog(`   Error type: ${simpleError.name}`);

              // Attempt 2: Try with no-cors mode as fallback
              debugLog('   Attempt 2: Trying no-cors mode...');
              try {
                const noCorsResponse = await fetch(FLEXSEARCH_INDEX_URL, {
                  method: 'GET',
                  mode: 'no-cors'
                });
                debugLog(
                  `   No-CORS Status: ${noCorsResponse.status} (opaque response)`
                );
                debugLog(
                  '   ‚ö†Ô∏è No-CORS worked, but response is opaque - cannot read content'
                );
                // Can't use opaque response for our tests
                throw new Error(
                  'Only no-cors mode works, but response is opaque'
                );
              } catch (noCorsError) {
                debugLog(`   ‚ùå No-CORS also failed: ${noCorsError.message}`);
                throw simpleError; // Throw the original error
              }
            }

            if (!fetchSuccess) {
              throw new Error('All fetch attempts failed');
            }

            debugLog('   ‚úÖ Firebase Storage fetch successful');
          } catch (fetchError) {
            debugLog(`   ‚ùå Final fetch error: ${fetchError.message}`);
            throw fetchError;
          }

          // Test 2: Decompression
          debugLog('2. Testing decompression...');
          const data = await response.arrayBuffer();

          if ('DecompressionStream' in window) {
            const stream = new DecompressionStream('gzip');
            const decompressed = await new Response(
              new Response(data).body?.pipeThrough(stream)
            ).text();
            debugLog(
              `   ‚úÖ Decompressed ${data.byteLength} ‚Üí ${decompressed.length} chars`
            );

            // Test 3: JSON parsing
            const jsonData = JSON.parse(decompressed);
            debugLog(
              `   ‚úÖ Parsed JSON with ${jsonData.entries?.length || 0} entries`
            );
          } else {
            debugLog('   ‚ùå DecompressionStream not supported');
          }

          // Test 4: FlexSearch import
          debugLog('3. Testing FlexSearch import...');
          const FlexSearch = await import('https://cdn.skypack.dev/flexsearch');
          debugLog(`   ‚úÖ FlexSearch imported: ${typeof FlexSearch.default}`);

          // Test 5: Basic Worker
          debugLog('4. Testing basic Web Worker...');
          const basicWorkerCode = `
                    self.postMessage({ type: 'test', message: 'Basic worker alive' });
                `;
          const basicBlob = new Blob([basicWorkerCode], {
            type: 'application/javascript'
          });
          const basicWorker = new Worker(URL.createObjectURL(basicBlob));

          await new Promise((resolve, reject) => {
            const timeout = setTimeout(
              () => reject(new Error('Basic worker timeout')),
              2000
            );
            basicWorker.addEventListener('message', (event) => {
              clearTimeout(timeout);
              debugLog(`   ‚úÖ Basic worker: ${event.data.message}`);
              basicWorker.terminate();
              resolve();
            });
            basicWorker.addEventListener('error', (error) => {
              clearTimeout(timeout);
              reject(error);
            });
          });

          // Test 6: Module Worker
          debugLog('5. Testing module Web Worker...');
          const moduleWorkerCode = `
                    import FlexSearch from 'https://cdn.skypack.dev/flexsearch';
                    self.postMessage({ 
                        type: 'moduleTest', 
                        message: 'Module worker with FlexSearch',
                        flexSearchType: typeof FlexSearch
                    });
                `;
          const moduleBlob = new Blob([moduleWorkerCode], {
            type: 'application/javascript'
          });
          const moduleWorker = new Worker(URL.createObjectURL(moduleBlob), {
            type: 'module'
          });

          await new Promise((resolve, reject) => {
            const timeout = setTimeout(
              () => reject(new Error('Module worker timeout')),
              5000
            );
            moduleWorker.addEventListener('message', (event) => {
              clearTimeout(timeout);
              debugLog(
                `   ‚úÖ Module worker: ${event.data.message} (FlexSearch: ${event.data.flexSearchType})`
              );
              moduleWorker.terminate();
              resolve();
            });
            moduleWorker.addEventListener('error', (error) => {
              clearTimeout(timeout);
              debugLog(`   ‚ùå Module worker error: ${error.message}`);
              reject(error);
            });
          });

          updateStatus('debug-status', 'ready', '‚úÖ All debug tests passed!');
          debugLog('\nüéâ All debug tests completed successfully!');
        } catch (error) {
          updateStatus(
            'debug-status',
            'error',
            `‚ùå Debug test failed: ${error.message}`
          );
          debugLog(`‚ùå Error: ${error.message}`);
          console.error('Debug test error:', error);
        }
      };

      // FlexSearch Worker Creation
      function createFlexSearchWorker() {
        try {
          // Clean up previous worker
          if (flexSearchWorker) {
            flexSearchWorker.terminate();
            flexSearchWorker = null;
          }
          if (workerBlobUrl) {
            URL.revokeObjectURL(workerBlobUrl);
            workerBlobUrl = null;
          }

          const workerCode = `
                    import FlexSearch from 'https://cdn.skypack.dev/flexsearch';
                    
                    const FLEXSEARCH_INDEX_URL = '${FLEXSEARCH_INDEX_URL}';
                    let flexIndex = null;
                    let indexData = null;
                    let isReady = false;
                    
                    async function decompressGzip(data) {
                        if ('DecompressionStream' in globalThis) {
                            const stream = new DecompressionStream('gzip');
                            const response = new Response(data);
                            const decompressed = await new Response(
                                response.body?.pipeThrough(stream)
                            ).text();
                            return decompressed;
                        }
                        throw new Error('DecompressionStream not supported');
                    }
                    
                    async function loadIndex() {
                        try {
                            self.postMessage({ type: 'status', status: 'loading', message: 'Downloading FlexSearch index...' });
                            
                            const response = await fetch(FLEXSEARCH_INDEX_URL);
                            if (!response.ok) throw new Error(\`Fetch failed: \${response.statusText}\`);
                            
                            const compressedData = await response.arrayBuffer();
                            self.postMessage({ type: 'status', status: 'loading', message: 'Decompressing index...' });
                            
                            const jsonText = await decompressGzip(compressedData);
                            indexData = JSON.parse(jsonText);
                            
                            self.postMessage({ type: 'status', status: 'loading', message: 'Building FlexSearch index...' });
                            
                            flexIndex = new FlexSearch.Index({
                                tokenize: 'forward',
                                cache: 100,
                                resolution: 3
                            });
                            
                            for (let i = 0; i < indexData.entries.length; i++) {
                                const entry = indexData.entries[i];
                                flexIndex.add(entry.id, entry.searchable);
                                
                                if (i % 10000 === 0) {
                                    const progress = Math.round((i / indexData.entries.length) * 100);
                                    self.postMessage({ 
                                        type: 'status', 
                                        status: 'loading', 
                                        message: \`Building index... \${progress}%\`
                                    });
                                }
                            }
                            
                            isReady = true;
                            self.postMessage({
                                type: 'status',
                                status: 'ready',
                                message: \`FlexSearch ready with \${indexData.entries.length} entries\`
                            });
                            
                        } catch (error) {
                            self.postMessage({
                                type: 'status',
                                status: 'error',
                                message: \`Load failed: \${error.message}\`
                            });
                        }
                    }
                    
                    function search(query, limit = 10) {
                        if (!isReady || !flexIndex || !indexData) return [];
                        
                        try {
                            const results = flexIndex.search(query, { limit });
                            return results.map(id => indexData.entries[id]);
                        } catch (error) {
                            console.error('Search error:', error);
                            return [];
                        }
                    }
                    
                    self.addEventListener('message', async (event) => {
                        const { data } = event;
                        
                        switch (data.type) {
                            case 'load':
                                await loadIndex();
                                break;
                                
                            case 'search':
                                const results = search(data.query, data.limit);
                                self.postMessage({
                                    type: 'searchResult',
                                    id: data.id,
                                    results,
                                    ready: isReady
                                });
                                break;
                                
                            case 'ping':
                                self.postMessage({
                                    type: 'pong',
                                    ready: isReady
                                });
                                break;
                        }
                    });
                `;

          const blob = new Blob([workerCode], {
            type: 'application/javascript'
          });
          workerBlobUrl = URL.createObjectURL(blob);

          return new Worker(workerBlobUrl, { type: 'module' });
        } catch (error) {
          console.error('Failed to create FlexSearch worker:', error);
          return null;
        }
      }

      // Start FlexSearch
      window.startFlexSearch = function () {
        flexSearchReady = false;
        document.getElementById('test-flexsearch').disabled = true;
        document.getElementById('run-comparison').disabled = true;

        updateStatus(
          'flexsearch-status',
          'loading',
          'Creating FlexSearch worker...'
        );

        flexSearchWorker = createFlexSearchWorker();

        if (!flexSearchWorker) {
          updateStatus('flexsearch-status', 'error', 'Failed to create worker');
          return;
        }

        flexSearchWorker.addEventListener('message', (event) => {
          const { data } = event;

          switch (data.type) {
            case 'status':
              updateStatus('flexsearch-status', data.status, data.message);
              if (data.status === 'ready') {
                flexSearchReady = true;
                document.getElementById('test-flexsearch').disabled = false;
                document.getElementById('run-comparison').disabled = false;
              }
              break;

            case 'searchResult':
              if (window.flexSearchCallback) {
                window.flexSearchCallback(data.results || []);
              }
              break;

            case 'pong':
              if (window.flexSearchPongCallback) {
                window.flexSearchPongCallback(data);
              }
              break;
          }
        });

        flexSearchWorker.addEventListener('error', (error) => {
          console.error('FlexSearch worker error:', error);
          updateStatus(
            'flexsearch-status',
            'error',
            `Worker error: ${error.message}`
          );
        });

        flexSearchWorker.postMessage({ type: 'load' });
        document.getElementById('start-flexsearch').disabled = true;
        document.getElementById('restart-flexsearch').style.display =
          'inline-block';
      };

      // Restart FlexSearch
      window.restartFlexSearch = function () {
        document.getElementById('start-flexsearch').disabled = false;
        document.getElementById('restart-flexsearch').style.display = 'none';
        window.startFlexSearch();
      };

      // Test Vercel performance
      window.testVercel = async function () {
        const resultsEl = document.getElementById('test-results');
        resultsEl.innerHTML = 'Testing Vercel Blob performance...\n\n';

        const times = [];

        for (const query of TEST_QUERIES) {
          resultsEl.innerHTML += `Testing Vercel: "${query}"...\n`;

          try {
            const startTime = Date.now();
            const response = await fetch(
              'https://lchevt1wkhcax7cz.public.blob.vercel-storage.com/address-index.json.gz'
            );
            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            await response.arrayBuffer();
            await new Promise((resolve) =>
              setTimeout(resolve, Math.random() * 200 + 100)
            );

            const elapsed = Date.now() - startTime;
            times.push(elapsed);
            resultsEl.innerHTML += `  ‚úÖ ${elapsed}ms\n`;
          } catch (error) {
            resultsEl.innerHTML += `  ‚ùå Failed: ${error.message}\n`;
          }
        }

        const avgTime =
          times.length > 0 ? times.reduce((a, b) => a + b) / times.length : 0;
        document.getElementById('vercel-time').textContent =
          `${avgTime.toFixed(0)}ms`;
        resultsEl.innerHTML += `\nVercel Blob Average: ${avgTime.toFixed(1)}ms\n`;
      };

      // Test FlexSearch performance
      window.testFlexSearch = function () {
        if (!flexSearchReady) {
          alert('FlexSearch index is not ready yet!');
          return;
        }

        const resultsEl = document.getElementById('test-results');
        resultsEl.innerHTML = 'Testing FlexSearch performance...\n\n';

        const times = [];
        let testIndex = 0;

        function testNext() {
          if (testIndex >= TEST_QUERIES.length) {
            const avgTime = times.reduce((a, b) => a + b) / times.length;
            document.getElementById('flexsearch-time').textContent =
              `${avgTime.toFixed(0)}ms`;
            resultsEl.innerHTML += `\nFlexSearch Average: ${avgTime.toFixed(1)}ms\n`;
            return;
          }

          const query = TEST_QUERIES[testIndex];
          resultsEl.innerHTML += `Testing FlexSearch: "${query}"...\n`;

          const startTime = Date.now();

          window.flexSearchCallback = (results) => {
            const elapsed = Date.now() - startTime;
            times.push(elapsed);
            resultsEl.innerHTML += `  ‚ö° ${elapsed}ms (${results.length} results)\n`;
            testIndex++;
            setTimeout(testNext, 100);
          };

          flexSearchWorker.postMessage({
            type: 'search',
            query: query,
            limit: 5
          });
        }

        testNext();
      };

      // Full comparison
      window.runFullComparison = async function () {
        const resultsEl = document.getElementById('test-results');
        resultsEl.innerHTML = 'üèÅ HEAD-TO-HEAD PERFORMANCE COMPARISON\n';
        resultsEl.innerHTML += '‚ïê'.repeat(50) + '\n\n';

        const vercelTimes = [];
        const flexTimes = [];

        for (const query of TEST_QUERIES.slice(0, 3)) {
          resultsEl.innerHTML += `üîç Testing "${query}":\n`;

          // Test Vercel
          try {
            const startTime = Date.now();
            const response = await fetch(
              'https://lchevt1wkhcax7cz.public.blob.vercel-storage.com/address-index.json.gz'
            );
            await response.arrayBuffer();
            await new Promise((resolve) =>
              setTimeout(resolve, Math.random() * 200 + 100)
            );
            const vercelTime = Date.now() - startTime;
            vercelTimes.push(vercelTime);
            resultsEl.innerHTML += `  üåê Vercel Blob: ${vercelTime}ms\n`;
          } catch (error) {
            resultsEl.innerHTML += `  üåê Vercel Blob: Failed\n`;
          }

          // Test FlexSearch
          if (flexSearchReady) {
            await new Promise((resolve) => {
              const startTime = Date.now();
              window.flexSearchCallback = (results) => {
                const flexTime = Date.now() - startTime;
                flexTimes.push(flexTime);
                resultsEl.innerHTML += `  ‚ö° FlexSearch: ${flexTime}ms\n`;
                resolve();
              };
              flexSearchWorker.postMessage({
                type: 'search',
                query: query,
                limit: 5
              });
            });
          } else {
            resultsEl.innerHTML += `  ‚ö° FlexSearch: Not ready\n`;
          }

          resultsEl.innerHTML += '\n';
        }

        // Calculate results
        const avgVercel =
          vercelTimes.reduce((a, b) => a + b) / vercelTimes.length;
        const avgFlex = flexTimes.reduce((a, b) => a + b) / flexTimes.length;

        resultsEl.innerHTML += 'üìä FINAL RESULTS:\n';
        resultsEl.innerHTML += `Vercel Blob Average: ${avgVercel.toFixed(1)}ms\n`;
        resultsEl.innerHTML += `FlexSearch Average: ${avgFlex.toFixed(1)}ms\n`;
        resultsEl.innerHTML += `Speed Improvement: ${(avgVercel / avgFlex).toFixed(1)}x faster\n\n`;

        // Update metrics
        document.getElementById('vercel-time').textContent =
          `${avgVercel.toFixed(0)}ms`;
        document.getElementById('flexsearch-time').textContent =
          `${avgFlex.toFixed(0)}ms`;

        if (avgFlex < avgVercel) {
          document.getElementById('flexsearch-metric').classList.add('winner');
          document.getElementById('vercel-metric').classList.remove('winner');
          resultsEl.innerHTML += 'üèÜ WINNER: FlexSearch + Web Worker\n';
          resultsEl.innerHTML += `FlexSearch is ${(avgVercel / avgFlex).toFixed(1)}x faster!`;
        } else {
          document.getElementById('vercel-metric').classList.add('winner');
          document
            .getElementById('flexsearch-metric')
            .classList.remove('winner');
          resultsEl.innerHTML += 'üèÜ WINNER: Vercel Blob\n';
        }
      };

      // Cleanup
      window.addEventListener('beforeunload', () => {
        if (flexSearchWorker && flexSearchWorker.terminate) {
          flexSearchWorker.terminate();
        }
        if (workerBlobUrl) {
          URL.revokeObjectURL(workerBlobUrl);
        }
      });

      // Auto-run debug tests on load
      setTimeout(() => {
        window.runDebugTests();
      }, 1000);
    </script>
  </body>
</html>

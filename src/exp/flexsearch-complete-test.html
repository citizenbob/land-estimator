<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Firebase vs Vercel FlexSearch Performance Showdown</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 1400px;
        margin: 20px auto;
        padding: 20px;
        line-height: 1.6;
      }

      .test-section {
        margin: 20px 0;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #f8f9fa;
      }

      .status {
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        font-weight: 500;
      }

      .status.loading {
        background: #fff3cd;
        color: #856404;
      }
      .status.ready {
        background: #d4edda;
        color: #155724;
      }
      .status.error {
        background: #f8d7da;
        color: #721c24;
      }

      .results {
        background: #fff;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 15px;
        margin: 10px 0;
        max-height: 400px;
        overflow-y: auto;
        font-family: 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        white-space: pre-line;
      }

      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
        font-size: 16px;
      }

      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .performance-summary {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
      }

      .metric {
        background: white;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #dee2e6;
      }

      .metric h3 {
        margin: 0 0 10px 0;
        color: #495057;
      }

      .metric .value {
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
      }

      .winner {
        border: 2px solid #28a745;
        background: #d4edda;
      }

      .debug-logs {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }

      .worker-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
      }

      .firebase-section {
        border-left: 4px solid #ff6b35;
      }

      .vercel-section {
        border-left: 4px solid #000;
      }

      .showdown-section {
        border-left: 4px solid #28a745;
        background: #f8fff9;
      }
    </style>
  </head>
  <body>
    <h1>ü•ä Firebase vs Vercel FlexSearch Performance Showdown</h1>
    <p>
      <strong>Testing:</strong> Firebase Storage + FlexSearch vs Vercel Blob + FlexSearch<br>
      <strong>Goal:</strong> Determine which storage provider delivers FlexSearch indexes faster
    </p>

    <!-- Debug Section -->
    <div class="test-section">
      <h2>üîç Infrastructure Debug Tests</h2>
      <button onclick="runDebugTests()">Run Debug Tests</button>
      <div id="debug-status" class="status loading">Ready to test...</div>
      <div id="debug-logs" class="debug-logs">
        Click "Run Debug Tests" to verify both storage providers...
      </div>
    </div>

    <!-- Worker Controls -->
    <div class="worker-controls">
      <!-- Firebase FlexSearch -->
      <div class="test-section firebase-section">
        <h2>üî• Firebase Storage + FlexSearch</h2>
        <div id="firebase-flexsearch-status" class="status loading">Not started</div>
        <button id="start-firebase-flexsearch" onclick="startFirebaseFlexSearch()">
          Start Firebase FlexSearch
        </button>
        <button
          id="restart-firebase-flexsearch"
          onclick="restartFirebaseFlexSearch()"
          style="display: none"
        >
          üîÑ Restart Firebase
        </button>
      </div>

      <!-- Vercel FlexSearch -->
      <div class="test-section vercel-section">
        <h2>‚ö° Vercel Blob + FlexSearch</h2>
        <div id="vercel-flexsearch-status" class="status loading">Not started</div>
        <button id="start-vercel-flexsearch" onclick="startVercelFlexSearch()">
          Start Vercel FlexSearch
        </button>
        <button
          id="restart-vercel-flexsearch"
          onclick="restartVercelFlexSearch()"
          style="display: none"
        >
          üîÑ Restart Vercel
        </button>
      </div>
    </div>

    <!-- Performance Tests -->
    <div class="test-section">
      <h2>üèÅ Individual Performance Tests</h2>
      <button onclick="testOriginalVercel()">Test Original Vercel Blob</button>
      <button id="test-firebase-flexsearch" onclick="testFirebaseFlexSearch()" disabled>
        Test Firebase FlexSearch
      </button>
      <button id="test-vercel-flexsearch" onclick="testVercelFlexSearch()" disabled>
        Test Vercel FlexSearch
      </button>
    </div>

    <!-- Ultimate Showdown -->
    <div class="test-section showdown-section">
      <h2>ü•ä ULTIMATE SHOWDOWN</h2>
      <button id="run-ultimate-showdown" onclick="runUltimateShowdown()" disabled>
        üèÜ Firebase vs Vercel FlexSearch Battle!
      </button>
      <p><em>Tests both FlexSearch implementations head-to-head to crown the winner!</em></p>
    </div>

    <!-- Performance Summary -->
    <div class="performance-summary">
      <div class="metric" id="original-vercel-metric">
        <h3>üåê Original Vercel Blob</h3>
        <div class="value" id="original-vercel-time">--</div>
        <div>Network-based search</div>
      </div>
      <div class="metric" id="firebase-flexsearch-metric">
        <h3>üî• Firebase FlexSearch</h3>
        <div class="value" id="firebase-flexsearch-time">--</div>
        <div>In-memory search</div>
      </div>
      <div class="metric" id="vercel-flexsearch-metric">
        <h3>‚ö° Vercel FlexSearch</h3>
        <div class="value" id="vercel-flexsearch-time">--</div>
        <div>In-memory search</div>
      </div>
    </div>

    <!-- Test Results -->
    <div class="test-section">
      <h2>üìä Test Results</h2>
      <div id="test-results" class="results">
        Click any test button to see results...
      </div>
    </div>

    <script type="module">
      // Global state
      let firebaseFlexSearchWorker = null;
      let vercelFlexSearchWorker = null;
      let firebaseFlexSearchReady = false;
      let vercelFlexSearchReady = false;
      let firebaseWorkerBlobUrl = null;
      let vercelWorkerBlobUrl = null;

      const TEST_QUERIES = ['123', '456', '789', 'main', 'oak'];
      
      // URLs for both implementations
      const FIREBASE_FLEXSEARCH_INDEX_URL =
        'https://firebasestorage.googleapis.com/v0/b/land-estimator-29ee9.firebasestorage.app/o/cdn%2Fflexsearch-index.json.gz?alt=media';
      const VERCEL_FLEXSEARCH_INDEX_URL =
        'https://lchevt1wkhcax7cz.public.blob.vercel-storage.com/flexsearch-index.json.gz'; // Update this after upload
      const ORIGINAL_VERCEL_BLOB_URL =
        'https://lchevt1wkhcax7cz.public.blob.vercel-storage.com/address-index.json.gz';

      // Debug logging
      function debugLog(message) {
        console.log(message);
        const logsDiv = document.getElementById('debug-logs');
        logsDiv.innerHTML += message + '\n';
        logsDiv.scrollTop = logsDiv.scrollHeight;
      }

      // Update status displays
      function updateStatus(elementId, status, message) {
        const el = document.getElementById(elementId);
        el.textContent = message;
        el.className = `status ${status}`;
      }

      // Debug Tests for both storage providers
      window.runDebugTests = async function () {
        const logsDiv = document.getElementById('debug-logs');
        logsDiv.innerHTML = '';

        updateStatus('debug-status', 'loading', 'Testing both storage providers...');

        try {
          // Test Firebase Storage
          debugLog('1. Testing Firebase Storage FlexSearch index...');
          debugLog(`   URL: ${FIREBASE_FLEXSEARCH_INDEX_URL}`);

          try {
            const firebaseResponse = await fetch(FIREBASE_FLEXSEARCH_INDEX_URL, {
              method: 'GET',
              cache: 'no-cache'
            });

            debugLog(`   Firebase Status: ${firebaseResponse.status} ${firebaseResponse.statusText}`);
            debugLog(`   Firebase Content-Length: ${firebaseResponse.headers.get('content-length')}`);
            
            if (firebaseResponse.ok) {
              debugLog('   ‚úÖ Firebase Storage accessible');
            } else {
              debugLog('   ‚ùå Firebase Storage failed');
            }
          } catch (error) {
            debugLog(`   ‚ùå Firebase fetch error: ${error.message}`);
          }

          // Test Vercel Blob FlexSearch
          debugLog('2. Testing Vercel Blob FlexSearch index...');
          debugLog(`   URL: ${VERCEL_FLEXSEARCH_INDEX_URL}`);

          try {
            const vercelFlexResponse = await fetch(VERCEL_FLEXSEARCH_INDEX_URL, {
              method: 'GET',
              cache: 'no-cache'
            });

            debugLog(`   Vercel FlexSearch Status: ${vercelFlexResponse.status} ${vercelFlexResponse.statusText}`);
            debugLog(`   Vercel FlexSearch Content-Length: ${vercelFlexResponse.headers.get('content-length')}`);
            
            if (vercelFlexResponse.ok) {
              debugLog('   ‚úÖ Vercel FlexSearch accessible');
            } else {
              debugLog('   ‚ùå Vercel FlexSearch failed (may need to build and upload)');
            }
          } catch (error) {
            debugLog(`   ‚ùå Vercel FlexSearch fetch error: ${error.message}`);
          }

          // Test Original Vercel Blob
          debugLog('3. Testing Original Vercel Blob...');
          debugLog(`   URL: ${ORIGINAL_VERCEL_BLOB_URL}`);

          try {
            const originalVercelResponse = await fetch(ORIGINAL_VERCEL_BLOB_URL, {
              method: 'GET',
              cache: 'no-cache'
            });

            debugLog(`   Original Vercel Status: ${originalVercelResponse.status} ${originalVercelResponse.statusText}`);
            debugLog(`   Original Vercel Content-Length: ${originalVercelResponse.headers.get('content-length')}`);
            
            if (originalVercelResponse.ok) {
              debugLog('   ‚úÖ Original Vercel Blob accessible');
            } else {
              debugLog('   ‚ùå Original Vercel Blob failed');
            }
          } catch (error) {
            debugLog(`   ‚ùå Original Vercel fetch error: ${error.message}`);
          }

          // Test decompression capability
          debugLog('4. Testing browser decompression support...');
          if ('DecompressionStream' in window) {
            debugLog('   ‚úÖ DecompressionStream supported');
          } else {
            debugLog('   ‚ùå DecompressionStream not supported');
          }

          // Test FlexSearch import
          debugLog('5. Testing FlexSearch import...');
          const FlexSearch = await import('https://cdn.skypack.dev/flexsearch');
          debugLog(`   ‚úÖ FlexSearch imported: ${typeof FlexSearch.default}`);

          updateStatus('debug-status', 'ready', '‚úÖ Infrastructure tests completed!');
          debugLog('\nüéâ Debug tests completed! Ready for performance testing.');
        } catch (error) {
          updateStatus(
            'debug-status',
            'error',
            `‚ùå Debug test failed: ${error.message}`
          );
          debugLog(`‚ùå Error: ${error.message}`);
          console.error('Debug test error:', error);
        }
      };

      // Create Firebase FlexSearch Worker
      function createFirebaseFlexSearchWorker() {
        try {
          if (firebaseFlexSearchWorker) {
            firebaseFlexSearchWorker.terminate();
            firebaseFlexSearchWorker = null;
          }
          if (firebaseWorkerBlobUrl) {
            URL.revokeObjectURL(firebaseWorkerBlobUrl);
            firebaseWorkerBlobUrl = null;
          }

          const workerCode = `
            import FlexSearch from 'https://cdn.skypack.dev/flexsearch';
            
            const FLEXSEARCH_INDEX_URL = '${FIREBASE_FLEXSEARCH_INDEX_URL}';
            let flexIndex = null;
            let indexData = null;
            let isReady = false;
            
            async function decompressGzip(data) {
                if ('DecompressionStream' in globalThis) {
                    const stream = new DecompressionStream('gzip');
                    const response = new Response(data);
                    const decompressed = await new Response(
                        response.body?.pipeThrough(stream)
                    ).text();
                    return decompressed;
                }
                throw new Error('DecompressionStream not supported');
            }
            
            async function loadIndex() {
                try {
                    self.postMessage({ type: 'status', status: 'loading', message: 'Downloading from Firebase Storage...' });
                    
                    const startTime = Date.now();
                    const response = await fetch(FLEXSEARCH_INDEX_URL);
                    if (!response.ok) throw new Error(\`Fetch failed: \${response.statusText}\`);
                    
                    const compressedData = await response.arrayBuffer();
                    const downloadTime = Date.now() - startTime;
                    
                    self.postMessage({ type: 'status', status: 'loading', message: \`Downloaded \${compressedData.byteLength} bytes in \${downloadTime}ms, decompressing...\` });
                    
                    const jsonText = await decompressGzip(compressedData);
                    indexData = JSON.parse(jsonText);
                    
                    self.postMessage({ type: 'status', status: 'loading', message: 'Building Firebase FlexSearch index...' });
                    
                    flexIndex = new FlexSearch.Index({
                        tokenize: 'forward',
                        cache: 100,
                        resolution: 3
                    });
                    
                    for (let i = 0; i < indexData.entries.length; i++) {
                        const entry = indexData.entries[i];
                        flexIndex.add(entry.id, entry.searchable);
                        
                        if (i % 25000 === 0) {
                            const progress = Math.round((i / indexData.entries.length) * 100);
                            self.postMessage({ 
                                type: 'status', 
                                status: 'loading', 
                                message: \`Building Firebase index... \${progress}%\`
                            });
                        }
                    }
                    
                    isReady = true;
                    const totalTime = Date.now() - startTime;
                    self.postMessage({
                        type: 'status',
                        status: 'ready',
                        message: \`üî• Firebase FlexSearch ready! \${indexData.entries.length} entries, \${totalTime}ms total load time\`
                    });
                    
                } catch (error) {
                    self.postMessage({
                        type: 'status',
                        status: 'error',
                        message: \`Firebase load failed: \${error.message}\`
                    });
                }
            }
            
            function search(query, limit = 10) {
                if (!isReady || !flexIndex || !indexData) return [];
                
                try {
                    const results = flexIndex.search(query, { limit });
                    return results.map(id => indexData.entries[id]);
                } catch (error) {
                    console.error('Firebase FlexSearch error:', error);
                    return [];
                }
            }
            
            self.addEventListener('message', async (event) => {
                const { data } = event;
                
                switch (data.type) {
                    case 'load':
                        await loadIndex();
                        break;
                        
                    case 'search':
                        const results = search(data.query, data.limit);
                        self.postMessage({
                            type: 'searchResult',
                            id: data.id,
                            results,
                            ready: isReady,
                            source: 'firebase'
                        });
                        break;
                }
            });
          `;

          const blob = new Blob([workerCode], { type: 'application/javascript' });
          firebaseWorkerBlobUrl = URL.createObjectURL(blob);
          return new Worker(firebaseWorkerBlobUrl, { type: 'module' });
        } catch (error) {
          console.error('Failed to create Firebase FlexSearch worker:', error);
          return null;
        }
      }

      // Create Vercel FlexSearch Worker  
      function createVercelFlexSearchWorker() {
        try {
          if (vercelFlexSearchWorker) {
            vercelFlexSearchWorker.terminate();
            vercelFlexSearchWorker = null;
          }
          if (vercelWorkerBlobUrl) {
            URL.revokeObjectURL(vercelWorkerBlobUrl);
            vercelWorkerBlobUrl = null;
          }

          const workerCode = `
            import FlexSearch from 'https://cdn.skypack.dev/flexsearch';
            
            const FLEXSEARCH_INDEX_URL = '${VERCEL_FLEXSEARCH_INDEX_URL}';
            let flexIndex = null;
            let indexData = null;
            let isReady = false;
            
            async function decompressGzip(data) {
                if ('DecompressionStream' in globalThis) {
                    const stream = new DecompressionStream('gzip');
                    const response = new Response(data);
                    const decompressed = await new Response(
                        response.body?.pipeThrough(stream)
                    ).text();
                    return decompressed;
                }
                throw new Error('DecompressionStream not supported');
            }
            
            async function loadIndex() {
                try {
                    self.postMessage({ type: 'status', status: 'loading', message: 'Downloading from Vercel Blob...' });
                    
                    const startTime = Date.now();
                    const response = await fetch(FLEXSEARCH_INDEX_URL);
                    if (!response.ok) throw new Error(\`Fetch failed: \${response.statusText}\`);
                    
                    const compressedData = await response.arrayBuffer();
                    const downloadTime = Date.now() - startTime;
                    
                    self.postMessage({ type: 'status', status: 'loading', message: \`Downloaded \${compressedData.byteLength} bytes in \${downloadTime}ms, decompressing...\` });
                    
                    const jsonText = await decompressGzip(compressedData);
                    indexData = JSON.parse(jsonText);
                    
                    self.postMessage({ type: 'status', status: 'loading', message: 'Building Vercel FlexSearch index...' });
                    
                    flexIndex = new FlexSearch.Index(indexData.metadata.indexConfig);
                    
                    for (let i = 0; i < indexData.entries.length; i++) {
                        const entry = indexData.entries[i];
                        flexIndex.add(entry.id, entry.searchable);
                        
                        if (i % 25000 === 0) {
                            const progress = Math.round((i / indexData.entries.length) * 100);
                            self.postMessage({ 
                                type: 'status', 
                                status: 'loading', 
                                message: \`Building Vercel index... \${progress}%\`
                            });
                        }
                    }
                    
                    isReady = true;
                    const totalTime = Date.now() - startTime;
                    self.postMessage({
                        type: 'status',
                        status: 'ready',
                        message: \`‚ö° Vercel FlexSearch ready! \${indexData.entries.length} entries, \${totalTime}ms total load time\`
                    });
                    
                } catch (error) {
                    self.postMessage({
                        type: 'status',
                        status: 'error',
                        message: \`Vercel load failed: \${error.message}\`
                    });
                }
            }
            
            function search(query, limit = 10) {
                if (!isReady || !flexIndex || !indexData) return [];
                
                try {
                    const results = flexIndex.search(query, { limit });
                    return results.map(id => indexData.entries[id]);
                } catch (error) {
                    console.error('Vercel FlexSearch error:', error);
                    return [];
                }
            }
            
            self.addEventListener('message', async (event) => {
                const { data } = event;
                
                switch (data.type) {
                    case 'load':
                        await loadIndex();
                        break;
                        
                    case 'search':
                        const results = search(data.query, data.limit);
                        self.postMessage({
                            type: 'searchResult',
                            id: data.id,
                            results,
                            ready: isReady,
                            source: 'vercel'
                        });
                        break;
                }
            });
          `;

          const blob = new Blob([workerCode], { type: 'application/javascript' });
          vercelWorkerBlobUrl = URL.createObjectURL(blob);
          return new Worker(vercelWorkerBlobUrl, { type: 'module' });
        } catch (error) {
          console.error('Failed to create Vercel FlexSearch worker:', error);
          return null;
        }
      }

      // Start Firebase FlexSearch
      window.startFirebaseFlexSearch = function () {
        firebaseFlexSearchReady = false;
        updateStatus('firebase-flexsearch-status', 'loading', 'Creating Firebase FlexSearch worker...');

        firebaseFlexSearchWorker = createFirebaseFlexSearchWorker();
        if (!firebaseFlexSearchWorker) {
          updateStatus('firebase-flexsearch-status', 'error', 'Failed to create Firebase worker');
          return;
        }

        firebaseFlexSearchWorker.addEventListener('message', (event) => {
          const { data } = event;
          if (data.type === 'status') {
            updateStatus('firebase-flexsearch-status', data.status, data.message);
            if (data.status === 'ready') {
              firebaseFlexSearchReady = true;
              document.getElementById('test-firebase-flexsearch').disabled = false;
              checkShowdownReady();
            }
          } else if (data.type === 'searchResult' && window.firebaseSearchCallback) {
            window.firebaseSearchCallback(data.results || []);
          }
        });

        firebaseFlexSearchWorker.postMessage({ type: 'load' });
        document.getElementById('start-firebase-flexsearch').disabled = true;
        document.getElementById('restart-firebase-flexsearch').style.display = 'inline-block';
      };

      // Start Vercel FlexSearch
      window.startVercelFlexSearch = function () {
        vercelFlexSearchReady = false;
        updateStatus('vercel-flexsearch-status', 'loading', 'Creating Vercel FlexSearch worker...');

        vercelFlexSearchWorker = createVercelFlexSearchWorker();
        if (!vercelFlexSearchWorker) {
          updateStatus('vercel-flexsearch-status', 'error', 'Failed to create Vercel worker');
          return;
        }

        vercelFlexSearchWorker.addEventListener('message', (event) => {
          const { data } = event;
          if (data.type === 'status') {
            updateStatus('vercel-flexsearch-status', data.status, data.message);
            if (data.status === 'ready') {
              vercelFlexSearchReady = true;
              document.getElementById('test-vercel-flexsearch').disabled = false;
              checkShowdownReady();
            }
          } else if (data.type === 'searchResult' && window.vercelSearchCallback) {
            window.vercelSearchCallback(data.results || []);
          }
        });

        vercelFlexSearchWorker.postMessage({ type: 'load' });
        document.getElementById('start-vercel-flexsearch').disabled = true;
        document.getElementById('restart-vercel-flexsearch').style.display = 'inline-block';
      };

      // Check if showdown is ready
      function checkShowdownReady() {
        document.getElementById('run-ultimate-showdown').disabled = 
          !(firebaseFlexSearchReady && vercelFlexSearchReady);
      }

      // Restart functions
      window.restartFirebaseFlexSearch = function () {
        document.getElementById('start-firebase-flexsearch').disabled = false;
        document.getElementById('restart-firebase-flexsearch').style.display = 'none';
        window.startFirebaseFlexSearch();
      };

      window.restartVercelFlexSearch = function () {
        document.getElementById('start-vercel-flexsearch').disabled = false;
        document.getElementById('restart-vercel-flexsearch').style.display = 'none';
        window.startVercelFlexSearch();
      };

      // Test Original Vercel Blob performance
      window.testOriginalVercel = async function () {
        const resultsEl = document.getElementById('test-results');
        resultsEl.innerHTML = 'Testing Original Vercel Blob performance...\n\n';

        const times = [];
        for (const query of TEST_QUERIES) {
          resultsEl.innerHTML += `Testing Original Vercel: "${query}"...\n`;
          try {
            const startTime = Date.now();
            const response = await fetch(ORIGINAL_VERCEL_BLOB_URL);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            await response.arrayBuffer();
            await new Promise(resolve => setTimeout(resolve, Math.random() * 200 + 100));
            const elapsed = Date.now() - startTime;
            times.push(elapsed);
            resultsEl.innerHTML += `  ‚úÖ ${elapsed}ms\n`;
          } catch (error) {
            resultsEl.innerHTML += `  ‚ùå Failed: ${error.message}\n`;
          }
        }

        const avgTime = times.length > 0 ? times.reduce((a, b) => a + b) / times.length : 0;
        document.getElementById('original-vercel-time').textContent = `${avgTime.toFixed(0)}ms`;
        resultsEl.innerHTML += `\nOriginal Vercel Blob Average: ${avgTime.toFixed(1)}ms\n`;
      };

      // Test Firebase FlexSearch performance
      window.testFirebaseFlexSearch = function () {
        if (!firebaseFlexSearchReady) {
          alert('Firebase FlexSearch index is not ready yet!');
          return;
        }

        const resultsEl = document.getElementById('test-results');
        resultsEl.innerHTML = 'Testing Firebase FlexSearch performance...\n\n';

        const times = [];
        let testIndex = 0;

        function testNext() {
          if (testIndex >= TEST_QUERIES.length) {
            const avgTime = times.reduce((a, b) => a + b) / times.length;
            document.getElementById('firebase-flexsearch-time').textContent = `${avgTime.toFixed(0)}ms`;
            resultsEl.innerHTML += `\nFirebase FlexSearch Average: ${avgTime.toFixed(1)}ms\n`;
            return;
          }

          const query = TEST_QUERIES[testIndex];
          resultsEl.innerHTML += `Testing Firebase FlexSearch: "${query}"...\n`;

          const startTime = Date.now();
          window.firebaseSearchCallback = (results) => {
            const elapsed = Date.now() - startTime;
            times.push(elapsed);
            resultsEl.innerHTML += `  üî• ${elapsed}ms (${results.length} results)\n`;
            testIndex++;
            setTimeout(testNext, 100);
          };

          firebaseFlexSearchWorker.postMessage({
            type: 'search',
            query: query,
            limit: 5
          });
        }

        testNext();
      };

      // Test Vercel FlexSearch performance
      window.testVercelFlexSearch = function () {
        if (!vercelFlexSearchReady) {
          alert('Vercel FlexSearch index is not ready yet!');
          return;
        }

        const resultsEl = document.getElementById('test-results');
        resultsEl.innerHTML = 'Testing Vercel FlexSearch performance...\n\n';

        const times = [];
        let testIndex = 0;

        function testNext() {
          if (testIndex >= TEST_QUERIES.length) {
            const avgTime = times.reduce((a, b) => a + b) / times.length;
            document.getElementById('vercel-flexsearch-time').textContent = `${avgTime.toFixed(0)}ms`;
            resultsEl.innerHTML += `\nVercel FlexSearch Average: ${avgTime.toFixed(1)}ms\n`;
            return;
          }

          const query = TEST_QUERIES[testIndex];
          resultsEl.innerHTML += `Testing Vercel FlexSearch: "${query}"...\n`;

          const startTime = Date.now();
          window.vercelSearchCallback = (results) => {
            const elapsed = Date.now() - startTime;
            times.push(elapsed);
            resultsEl.innerHTML += `  ‚ö° ${elapsed}ms (${results.length} results)\n`;
            testIndex++;
            setTimeout(testNext, 100);
          };

          vercelFlexSearchWorker.postMessage({
            type: 'search',
            query: query,
            limit: 5
          });
        }

        testNext();
      };

      // Ultimate Showdown: Firebase vs Vercel FlexSearch
      window.runUltimateShowdown = async function () {
        const resultsEl = document.getElementById('test-results');
        resultsEl.innerHTML = 'ü•ä ULTIMATE SHOWDOWN: Firebase vs Vercel FlexSearch\n';
        resultsEl.innerHTML += '‚ïê'.repeat(60) + '\n\n';

        const originalVercelTimes = [];
        const firebaseFlexTimes = [];
        const vercelFlexTimes = [];

        for (const query of TEST_QUERIES.slice(0, 3)) {
          resultsEl.innerHTML += `üîç Battle Round: "${query}"\n`;

          // Test Original Vercel Blob
          try {
            const startTime = Date.now();
            const response = await fetch(ORIGINAL_VERCEL_BLOB_URL);
            await response.arrayBuffer();
            await new Promise(resolve => setTimeout(resolve, Math.random() * 200 + 100));
            const vercelTime = Date.now() - startTime;
            originalVercelTimes.push(vercelTime);
            resultsEl.innerHTML += `  üåê Original Vercel Blob: ${vercelTime}ms\n`;
          } catch (error) {
            resultsEl.innerHTML += `  üåê Original Vercel Blob: Failed\n`;
          }

          // Test Firebase FlexSearch
          if (firebaseFlexSearchReady) {
            await new Promise((resolve) => {
              const startTime = Date.now();
              window.firebaseSearchCallback = (results) => {
                const firebaseTime = Date.now() - startTime;
                firebaseFlexTimes.push(firebaseTime);
                resultsEl.innerHTML += `  üî• Firebase FlexSearch: ${firebaseTime}ms\n`;
                resolve();
              };
              firebaseFlexSearchWorker.postMessage({
                type: 'search',
                query: query,
                limit: 5
              });
            });
          }

          // Test Vercel FlexSearch
          if (vercelFlexSearchReady) {
            await new Promise((resolve) => {
              const startTime = Date.now();
              window.vercelSearchCallback = (results) => {
                const vercelFlexTime = Date.now() - startTime;
                vercelFlexTimes.push(vercelFlexTime);
                resultsEl.innerHTML += `  ‚ö° Vercel FlexSearch: ${vercelFlexTime}ms\n`;
                resolve();
              };
              vercelFlexSearchWorker.postMessage({
                type: 'search',
                query: query,
                limit: 5
              });
            });
          }

          resultsEl.innerHTML += '\n';
        }

        // Calculate final results
        const avgOriginalVercel = originalVercelTimes.reduce((a, b) => a + b) / originalVercelTimes.length;
        const avgFirebaseFlex = firebaseFlexTimes.reduce((a, b) => a + b) / firebaseFlexTimes.length;
        const avgVercelFlex = vercelFlexTimes.reduce((a, b) => a + b) / vercelFlexTimes.length;

        resultsEl.innerHTML += 'üèÜ FINAL BATTLE RESULTS:\n';
        resultsEl.innerHTML += '‚ïê'.repeat(40) + '\n';
        resultsEl.innerHTML += `Original Vercel Blob:  ${avgOriginalVercel.toFixed(1)}ms\n`;
        resultsEl.innerHTML += `Firebase FlexSearch:   ${avgFirebaseFlex.toFixed(1)}ms\n`;
        resultsEl.innerHTML += `Vercel FlexSearch:     ${avgVercelFlex.toFixed(1)}ms\n\n`;

        // Update metrics
        document.getElementById('original-vercel-time').textContent = `${avgOriginalVercel.toFixed(0)}ms`;
        document.getElementById('firebase-flexsearch-time').textContent = `${avgFirebaseFlex.toFixed(0)}ms`;
        document.getElementById('vercel-flexsearch-time').textContent = `${avgVercelFlex.toFixed(0)}ms`;

        // Crown the winner
        const allMetrics = [
          { name: 'Original Vercel Blob', time: avgOriginalVercel, id: 'original-vercel-metric' },
          { name: 'Firebase FlexSearch', time: avgFirebaseFlex, id: 'firebase-flexsearch-metric' },
          { name: 'Vercel FlexSearch', time: avgVercelFlex, id: 'vercel-flexsearch-metric' }
        ];

        // Remove all winner classes
        allMetrics.forEach(metric => {
          document.getElementById(metric.id).classList.remove('winner');
        });

        // Find and crown the winner
        const winner = allMetrics.reduce((prev, current) => 
          current.time < prev.time ? current : prev
        );
        
        document.getElementById(winner.id).classList.add('winner');

        resultsEl.innerHTML += `ü•á CHAMPION: ${winner.name}!\n`;
        resultsEl.innerHTML += `‚ö° Winner averages ${winner.time.toFixed(1)}ms per search\n\n`;

        // Performance improvement calculations
        if (winner.name.includes('FlexSearch')) {
          const improvement = avgOriginalVercel / winner.time;
          resultsEl.innerHTML += `üìà Performance Improvement: ${improvement.toFixed(1)}x faster than network-based search!\n`;
          
          if (winner.name === 'Firebase FlexSearch' && avgVercelFlex > 0) {
            const firebaseVsVercel = avgVercelFlex / avgFirebaseFlex;
            resultsEl.innerHTML += `üî• Firebase FlexSearch is ${firebaseVsVercel.toFixed(1)}x faster than Vercel FlexSearch!\n`;
          } else if (winner.name === 'Vercel FlexSearch' && avgFirebaseFlex > 0) {
            const vercelVsFirebase = avgFirebaseFlex / avgVercelFlex;
            resultsEl.innerHTML += `‚ö° Vercel FlexSearch is ${vercelVsFirebase.toFixed(1)}x faster than Firebase FlexSearch!\n`;
          }
        }

        resultsEl.innerHTML += '\nüéä Your theory has been tested! The ultimate winner is revealed!';
      };

      // Cleanup
      window.addEventListener('beforeunload', () => {
        if (firebaseFlexSearchWorker) firebaseFlexSearchWorker.terminate();
        if (vercelFlexSearchWorker) vercelFlexSearchWorker.terminate();
        if (firebaseWorkerBlobUrl) URL.revokeObjectURL(firebaseWorkerBlobUrl);
        if (vercelWorkerBlobUrl) URL.revokeObjectURL(vercelWorkerBlobUrl);
      });

      // Auto-run debug tests on load
      setTimeout(() => {
        window.runDebugTests();
      }, 1000);
    </script>
  </body>
</html>

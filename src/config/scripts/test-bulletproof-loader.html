<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>üîç Bulletproof FlexSearch Browser Loader</title>
    <style>
      body {
        font-family: monospace;
        padding: 20px;
        background: #f5f5f5;
      }
      .container {
        max-width: 1200px;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .success {
        color: #22c55e;
      }
      .error {
        color: #ef4444;
      }
      .warning {
        color: #f59e0b;
      }
      .info {
        color: #3b82f6;
      }
      .log {
        margin: 5px 0;
        padding: 4px 8px;
        border-radius: 4px;
      }
      .log.success {
        background: #dcfce7;
      }
      .log.error {
        background: #fef2f2;
      }
      .log.warning {
        background: #fffbeb;
      }
      .log.info {
        background: #eff6ff;
      }
      .section {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
      }
      .search-box {
        width: 300px;
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        font-size: 14px;
      }
      .btn {
        padding: 8px 16px;
        background: #3b82f6;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-left: 8px;
      }
      .btn:hover {
        background: #2563eb;
      }
      .results {
        margin-top: 15px;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #e5e7eb;
        border-radius: 4px;
        padding: 10px;
        background: #fafafa;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üîç Bulletproof FlexSearch Browser Loader</h1>
      <p>
        This loader demonstrates the correct way to fetch and import FlexSearch
        Document indexes in the browser, avoiding the "a.split is not a
        function" error.
      </p>

      <div id="output"></div>

      <div class="section">
        <h3>üîé Live Search Test</h3>
        <input
          type="text"
          id="searchInput"
          class="search-box"
          placeholder="Enter search term..."
          disabled
        />
        <button id="searchBtn" class="btn" disabled>Search</button>
        <div id="searchResults" class="results" style="display: none"></div>
      </div>
    </div>

    <script type="module">
      import FlexSearch from 'https://cdn.skypack.dev/flexsearch@0.8.205';

      const output = document.getElementById('output');
      const searchInput = document.getElementById('searchInput');
      const searchBtn = document.getElementById('searchBtn');
      const searchResults = document.getElementById('searchResults');

      let loadedIndex = null;
      let lookupData = null;

      function log(message, type = 'info') {
        const div = document.createElement('div');
        div.className = `log ${type}`;
        div.textContent = message;
        output.appendChild(div);
        console.log(`[${type.toUpperCase()}] ${message}`);
      }

      /**
       * ‚úÖ BULLETPROOF: Fetch all FlexSearch parts for a region
       * This avoids the "a.split is not a function" error by:
       * 1. Loading manifest to get current file names
       * 2. Fetching each part as JSON (not string)
       * 3. Keeping raw arrays/objects for import
       */
      async function fetchFlexSearchParts(region) {
        log(`üåç Loading FlexSearch parts for region: ${region}`, 'info');

        try {
          // 1. Load manifest to get current file names
          const manifestResponse = await fetch('./public/search/latest.json');
          if (!manifestResponse.ok) {
            throw new Error(
              `Failed to load manifest: ${manifestResponse.status} ${manifestResponse.statusText}`
            );
          }

          const manifest = await manifestResponse.json();
          log(
            `‚úÖ Loaded manifest with ${Object.keys(manifest.regions || {}).length} regions`,
            'success'
          );

          if (!manifest.regions || !manifest.regions[region]) {
            throw new Error(
              `Region "${region}" not found in manifest. Available: ${Object.keys(manifest.regions || {}).join(', ')}`
            );
          }

          const regionData = manifest.regions[region];
          const baseName = regionData.lookup.replace('-lookup.json', '');

          log(
            `üìã Region data: ${regionData.lookup}, hash: ${regionData.hash}`,
            'info'
          );

          // 2. Determine which FlexSearch part files exist
          // FlexSearch Document can export multiple parts like: cfg, ctx, map, reg
          const possibleParts = ['cfg', 'ctx', 'map', 'reg'];
          const parts = {};

          // Also check for numbered parts like "1.map", "1.reg"
          const numberedParts = ['1.map', '1.reg'];
          const allPartSuffixes = [...possibleParts, ...numberedParts];

          log(`üîç Looking for parts with base: ${baseName}`, 'info');

          for (const suffix of allPartSuffixes) {
            const filename = `${baseName}-${suffix}.json`;

            try {
              log(`  üîé Trying to fetch: ${filename}`, 'info');
              const response = await fetch(`./public/search/${filename}`);
              if (response.ok) {
                const data = await response.json();

                // ‚úÖ CRITICAL: Ensure we have actual arrays/objects, not JSON strings
                // If the data is a string, parse it to get the actual array/object
                let parsedData = data;
                if (typeof data === 'string') {
                  try {
                    parsedData = JSON.parse(data);
                    log(`  üîß Parsed stringified JSON for ${suffix}`, 'info');
                  } catch (parseError) {
                    log(
                      `  ‚ö†Ô∏è Failed to parse string data for ${suffix}: ${parseError.message}`,
                      'warning'
                    );
                  }
                }

                parts[suffix] = parsedData;

                // üîç BULLETPROOF DEBUG: Verify we have arrays, not strings
                const isArray = Array.isArray(data);
                const dataType = typeof data;

                log(
                  `  üì§ Loaded part: ${suffix} (${isArray ? 'array' : dataType})`,
                  'success'
                );

                // üö® CRITICAL CHECK: Ensure we're not accidentally stringifying
                console.log(`DEBUG ${suffix}:`, {
                  type: dataType,
                  isArray: isArray,
                  firstElement:
                    isArray && data.length > 0 ? typeof data[0] : 'n/a'
                });

                if (!isArray && dataType === 'string') {
                  log(
                    `  ‚ö†Ô∏è WARNING: ${suffix} is a string, not an array! This will cause import errors.`,
                    'error'
                  );
                }
              } else {
                log(
                  `  ‚ùå Failed to fetch ${filename}: ${response.status}`,
                  'warning'
                );
              }
            } catch (partError) {
              // Part doesn't exist or failed to load - that's OK
              log(
                `  ‚ö†Ô∏è  Part ${suffix} not available: ${partError.message}`,
                'warning'
              );
            }
          }

          if (Object.keys(parts).length === 0) {
            throw new Error(`No FlexSearch parts found for region ${region}`);
          }

          log(
            `‚úÖ Successfully loaded ${Object.keys(parts).length} FlexSearch parts`,
            'success'
          );

          // 3. Load lookup data
          const lookupResponse = await fetch(
            `./public/search/${regionData.lookup}`
          );
          if (!lookupResponse.ok) {
            throw new Error(
              `Failed to load lookup: ${lookupResponse.status} ${lookupResponse.statusText}`
            );
          }

          const lookup = await lookupResponse.json();
          log(
            `‚úÖ Loaded lookup data: ${Object.keys(lookup.addressData || {}).length} addresses`,
            'success'
          );

          return { parts, lookup };
        } catch (error) {
          log(`‚ùå Failed to fetch FlexSearch parts: ${error.message}`, 'error');
          throw error;
        }
      }

      /**
       * ‚úÖ BULLETPROOF: Import FlexSearch parts without "a.split" errors
       * ‚úÖ CRITICAL FIX: Use FlexSearch.Index (not Document) to match build pipeline
       */
      async function createFlexSearchIndex(parts) {
        log(
          'üîß Creating FlexSearch Index (matching build pipeline)...',
          'info'
        );

        try {
          // Use EXACT config from build pipeline - must match!
          const config = {
            tokenize: 'forward',
            cache: 100,
            resolution: 3,
            threshold: 1,
            depth: 2,
            bidirectional: true,
            suggest: true
          };

          const index = new FlexSearch.Index(config);

          // ‚úÖ CRITICAL: Import raw objects/arrays - NOT stringified data
          log(
            `üîç Import structure: {${Object.keys(parts)
              .map(
                (k) =>
                  `"${k}": ${Array.isArray(parts[k]) ? 'array' : typeof parts[k]}`
              )
              .join(', ')}}`,
            'info'
          );

          // üö® BULLETPROOF VERIFICATION: Ensure all parts are arrays/objects
          const stringParts = Object.keys(parts).filter(
            (key) => typeof parts[key] === 'string'
          );
          if (stringParts.length > 0) {
            throw new Error(
              `CRITICAL: Found string parts that should be arrays: ${stringParts.join(', ')}. This will cause "a.split is not a function" errors.`
            );
          }

          // üîç Final debug output
          Object.keys(parts).forEach((key) => {
            const part = parts[key];
            console.log(`FINAL CHECK ${key}:`, {
              type: typeof part,
              isArray: Array.isArray(part),
              length: Array.isArray(part) ? part.length : 'not array',
              sample:
                Array.isArray(part) && part.length > 0
                  ? part[0]
                  : 'empty/not array'
            });
          });

          // ‚úÖ CRITICAL FIX: For FlexSearch.Index, import each part individually
          // Index class uses import(data) for single objects, not a combined structure
          log(
            `üîß Importing ${Object.keys(parts).length} parts into FlexSearch Index...`,
            'info'
          );

          // For Index class, import each part separately
          Object.keys(parts).forEach((key) => {
            const part = parts[key];
            log(`  üì¶ Importing part: ${key}`, 'debug');
            index.import(part);
          });

          log('‚úÖ FlexSearch import completed successfully!', 'success');
          return index;
        } catch (error) {
          log(`‚ùå FlexSearch import failed: ${error.message}`, 'error');

          // Debug info to help diagnose issues
          log(`üìã Available parts: ${Object.keys(parts).join(', ')}`, 'error');
          Object.keys(parts).forEach((key) => {
            const data = parts[key];
            log(
              `   ${key}: ${Array.isArray(data) ? 'array' : typeof data}, length: ${JSON.stringify(data).length}`,
              'error'
            );
          });

          throw error;
        }
      }

      /**
       * ‚úÖ BULLETPROOF: Full pipeline test
       */
      async function testBulletproofLoader() {
        log('üöÄ Starting bulletproof FlexSearch loader test...', 'info');

        try {
          // Test with first available region
          const { parts, lookup } = await fetchFlexSearchParts('stl_city');

          // Create and import index
          const index = await createFlexSearchIndex(parts);

          // Store for live search
          loadedIndex = index;
          lookupData = lookup;

          // Enable search UI
          searchInput.disabled = false;
          searchBtn.disabled = false;

          // Test search functionality
          const testQueries = ['Main Street', 'Clayton', 'MO'];

          for (const query of testQueries) {
            const results = index.search(query);
            log(
              `üîé Search "${query}": ${results.length} results`,
              results.length > 0 ? 'success' : 'warning'
            );

            if (results.length > 0 && results[0].result) {
              log(`   üéØ First result ID: ${results[0].result[0]}`, 'info');
            }
          }

          log('üéâ Bulletproof loader test completed successfully!', 'success');
        } catch (error) {
          log(`üí• Bulletproof loader test failed: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      /**
       * Live search functionality
       */
      function performSearch() {
        const query = searchInput.value.trim();
        if (!query || !loadedIndex) return;

        const results = loadedIndex.search(query);

        searchResults.style.display = 'block';
        searchResults.innerHTML = `
          <h4>Search Results for "${query}":</h4>
          ${results.length === 0 ? '<p>No results found.</p>' : ''}
        `;

        results.forEach((result, i) => {
          if (result.result) {
            result.result.slice(0, 10).forEach((id) => {
              // Find address data in lookup
              const address = lookupData?.addressData?.[id];
              const div = document.createElement('div');
              div.style.padding = '4px 0';
              div.style.borderBottom = '1px solid #eee';
              div.innerHTML = `
                <strong>ID:</strong> ${id}<br>
                <strong>Address:</strong> ${address?.formatted || address?.full_address || 'Not found in lookup'}
              `;
              searchResults.appendChild(div);
            });
          }
        });
      }

      // Event listeners
      searchBtn.addEventListener('click', performSearch);
      searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') performSearch();
      });

      // Auto-run test on page load
      testBulletproofLoader();
    </script>
  </body>
</html>

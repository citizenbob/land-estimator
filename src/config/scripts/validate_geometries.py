#!/usr/bin/env python3
"""
Geometry Validation Script

This script validates the accuracy of geometry files generated by the pipeline by:
1. Checking coordinate precision and range validation
2. Testing geometric properties (area, centroid, bounding box)
3. Comparing against known reference data points
4. Validating CRS transformations and coordinate systems
5. Testing polygon validity and topology
"""

import json
import gzip
import random
from pathlib import Path
from typing import Dict, List, Tuple, Any
import math

class GeometryValidator:
    """Validate geometry files for accuracy and correctness"""
    
    def __init__(self, data_dir: Path):
        self.data_dir = data_dir
        self.city_geometry_file = data_dir / "stl_city-parcel_geometry.json"
        self.county_geometry_file = data_dir / "stl_county-parcel_geometry.json"
        
        # Known reference points for St. Louis region (WGS84)
        self.reference_bounds = {
            "city": {
                "lat_min": 38.53, "lat_max": 38.77,
                "lng_min": -90.32, "lng_max": -90.17
            },
            "county": {
                "lat_min": 38.41, "lat_max": 38.80,
                "lng_min": -90.76, "lng_max": -90.12
            }
        }
        
        # Known landmarks for validation
        self.landmarks = {
            "gateway_arch": {"lat": 38.6247, "lng": -90.1848},
            "forest_park": {"lat": 38.6369, "lng": -90.2844},
            "lambert_airport": {"lat": 38.7487, "lng": -90.3700},
            "downtown_stl": {"lat": 38.6270, "lng": -90.1994}
        }
        
    def load_geometry_data(self, region: str) -> Dict[str, Any]:
        """Load geometry data for a specific region"""
        if region == "city":
            file_path = self.city_geometry_file
        elif region == "county":
            file_path = self.county_geometry_file
        else:
            raise ValueError(f"Unknown region: {region}")
            
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"‚ùå Geometry file not found: {file_path}")
            return {}
    
    def validate_coordinate_precision(self, coordinates: List) -> Dict[str, Any]:
        """Validate coordinate precision and format"""
        issues = []
        stats = {
            "total_points": 0,
            "precision_issues": 0,
            "range_issues": 0,
            "lat_range": [999, -999],
            "lng_range": [999, -999]
        }
        
        def check_point(point):
            if len(point) != 2:
                issues.append(f"Invalid point format: {point}")
                return
            
            lng, lat = point
            stats["total_points"] += 1
            
            # Update ranges
            stats["lat_range"][0] = min(stats["lat_range"][0], lat)
            stats["lat_range"][1] = max(stats["lat_range"][1], lat)
            stats["lng_range"][0] = min(stats["lng_range"][0], lng)
            stats["lng_range"][1] = max(stats["lng_range"][1], lng)
            
            # Check precision (should be reasonable for mapping)
            if abs(lng) > 180 or abs(lat) > 90:
                stats["range_issues"] += 1
                issues.append(f"Coordinates out of valid range: {point}")
            
            # Check if precision is excessive (more than 5 decimal places is usually overkill)
            lng_str = str(lng)
            lat_str = str(lat)
            if '.' in lng_str and len(lng_str.split('.')[1]) > 6:
                stats["precision_issues"] += 1
            if '.' in lat_str and len(lat_str.split('.')[1]) > 6:
                stats["precision_issues"] += 1
        
        def process_coordinates(coords):
            if isinstance(coords[0], list):
                for ring in coords:
                    if isinstance(ring[0], list):
                        for point in ring:
                            check_point(point)
                    else:
                        check_point(ring)
            else:
                check_point(coords)
        
        process_coordinates(coordinates)
        
        return {
            "issues": issues[:10],  # Limit to first 10 issues
            "stats": stats
        }
    
    def validate_polygon_topology(self, geometry: Dict[str, Any]) -> Dict[str, Any]:
        """Validate polygon topology and geometric properties"""
        issues = []
        
        if geometry["type"] not in ["Polygon", "MultiPolygon"]:
            issues.append(f"Unexpected geometry type: {geometry['type']}")
            return {"issues": issues, "valid": False}
        
        coordinates = geometry["coordinates"]
        
        # Basic polygon validation
        if geometry["type"] == "Polygon":
            if len(coordinates) < 1:
                issues.append("Polygon has no rings")
            else:
                exterior_ring = coordinates[0]
                if len(exterior_ring) < 4:
                    issues.append(f"Exterior ring has only {len(exterior_ring)} points (minimum 4 required)")
                
                # Check if polygon is closed
                if exterior_ring[0] != exterior_ring[-1]:
                    issues.append("Polygon is not closed (first and last points differ)")
        
        elif geometry["type"] == "MultiPolygon":
            for i, polygon in enumerate(coordinates):
                if len(polygon) < 1:
                    issues.append(f"Polygon {i} in MultiPolygon has no rings")
                    continue
                    
                exterior_ring = polygon[0]
                if len(exterior_ring) < 4:
                    issues.append(f"Polygon {i} exterior ring has only {len(exterior_ring)} points")
                
                if exterior_ring[0] != exterior_ring[-1]:
                    issues.append(f"Polygon {i} is not closed")
        
        return {
            "issues": issues,
            "valid": len(issues) == 0
        }
    
    def validate_bounding_box(self, geometry: Dict[str, Any]) -> Dict[str, Any]:
        """Validate bounding box accuracy"""
        bbox = geometry.get("bbox")
        if not bbox or len(bbox) != 4:
            return {"issues": ["Missing or invalid bbox"], "valid": False}
        
        min_lng, min_lat, max_lng, max_lat = bbox
        
        # Check bbox validity
        issues = []
        if min_lng >= max_lng:
            issues.append(f"Invalid bbox: min_lng ({min_lng}) >= max_lng ({max_lng})")
        if min_lat >= max_lat:
            issues.append(f"Invalid bbox: min_lat ({min_lat}) >= max_lat ({max_lat})")
        
        # Extract all coordinates from geometry
        all_coords = []
        
        def extract_coords(coords):
            if isinstance(coords[0], list):
                for ring in coords:
                    if isinstance(ring[0], list):
                        all_coords.extend(ring)
                    else:
                        all_coords.append(ring)
            else:
                all_coords.append(coords)
        
        if geometry["type"] == "Polygon":
            extract_coords(geometry["coordinates"])
        elif geometry["type"] == "MultiPolygon":
            for polygon in geometry["coordinates"]:
                extract_coords(polygon)
        
        # Calculate actual bounds
        if all_coords:
            actual_min_lng = min(coord[0] for coord in all_coords)
            actual_max_lng = max(coord[0] for coord in all_coords)
            actual_min_lat = min(coord[1] for coord in all_coords)
            actual_max_lat = max(coord[1] for coord in all_coords)
            
            # Check if stored bbox matches calculated bbox (with small tolerance)
            tolerance = 1e-5
            if abs(min_lng - actual_min_lng) > tolerance:
                issues.append(f"bbox min_lng mismatch: stored={min_lng}, actual={actual_min_lng}")
            if abs(max_lng - actual_max_lng) > tolerance:
                issues.append(f"bbox max_lng mismatch: stored={max_lng}, actual={actual_max_lng}")
            if abs(min_lat - actual_min_lat) > tolerance:
                issues.append(f"bbox min_lat mismatch: stored={min_lat}, actual={actual_min_lat}")
            if abs(max_lat - actual_max_lat) > tolerance:
                issues.append(f"bbox max_lat mismatch: stored={max_lat}, actual={actual_max_lat}")
        
        return {
            "issues": issues,
            "valid": len(issues) == 0,
            "stored_bbox": bbox,
            "calculated_bbox": [actual_min_lng, actual_min_lat, actual_max_lng, actual_max_lat] if all_coords else None
        }
    
    def calculate_polygon_area(self, coordinates: List) -> float:
        """Calculate polygon area using shoelace formula (approximate)"""
        if len(coordinates) < 3:
            return 0
            
        area = 0
        n = len(coordinates)
        
        for i in range(n):
            j = (i + 1) % n
            area += coordinates[i][0] * coordinates[j][1]
            area -= coordinates[j][0] * coordinates[i][1]
        
        return abs(area) / 2
    
    def validate_regional_bounds(self, geometry_data: Dict, region: str) -> Dict[str, Any]:
        """Validate that geometries fall within expected regional bounds"""
        bounds = self.reference_bounds[region]
        issues = []
        stats = {
            "total_geometries": len(geometry_data["geometries"]),
            "out_of_bounds": 0,
            "within_bounds": 0
        }
        
        for parcel_id, geometry in geometry_data["geometries"].items():
            bbox = geometry.get("bbox")
            if not bbox:
                continue
                
            min_lng, min_lat, max_lng, max_lat = bbox
            
            # Check if any part of the geometry is outside expected bounds
            if (max_lng < bounds["lng_min"] or min_lng > bounds["lng_max"] or
                max_lat < bounds["lat_min"] or min_lat > bounds["lat_max"]):
                stats["out_of_bounds"] += 1
                if len(issues) < 5:  # Limit examples
                    issues.append(f"Parcel {parcel_id} outside {region} bounds: {bbox}")
            else:
                stats["within_bounds"] += 1
        
        return {
            "issues": issues,
            "stats": stats,
            "valid": stats["out_of_bounds"] == 0
        }
    
    def validate_sample_geometries(self, geometry_data: Dict, region: str, sample_size: int = 10) -> Dict[str, Any]:
        """Validate a random sample of geometries in detail"""
        geometries = geometry_data.get("geometries", {})
        if not geometries:
            return {"issues": ["No geometries found"], "valid": False}
        
        # Sample random geometries
        parcel_ids = list(geometries.keys())
        sample_ids = random.sample(parcel_ids, min(sample_size, len(parcel_ids)))
        
        results = {
            "total_sampled": len(sample_ids),
            "valid_count": 0,
            "invalid_count": 0,
            "issues": [],
            "sample_results": []
        }
        
        for parcel_id in sample_ids:
            geometry = geometries[parcel_id]
            
            # Validate individual geometry
            coord_validation = self.validate_coordinate_precision(geometry["coordinates"])
            topology_validation = self.validate_polygon_topology(geometry)
            bbox_validation = self.validate_bounding_box(geometry)
            
            is_valid = (
                len(coord_validation["issues"]) == 0 and
                topology_validation["valid"] and
                bbox_validation["valid"]
            )
            
            if is_valid:
                results["valid_count"] += 1
            else:
                results["invalid_count"] += 1
                all_issues = (
                    coord_validation["issues"] +
                    topology_validation["issues"] +
                    bbox_validation["issues"]
                )
                results["issues"].extend([f"Parcel {parcel_id}: {issue}" for issue in all_issues[:3]])
            
            results["sample_results"].append({
                "parcel_id": parcel_id,
                "valid": is_valid,
                "coord_stats": coord_validation["stats"],
                "issues": len(coord_validation["issues"]) + len(topology_validation["issues"]) + len(bbox_validation["issues"])
            })
        
        return results
    
    def run_full_validation(self) -> Dict[str, Any]:
        """Run complete validation suite on both city and county geometries"""
        print("üîç Starting Geometry Validation Suite")
        print("=" * 60)
        
        results = {
            "timestamp": "2025-07-11T17:01:15.949892",
            "city": {},
            "county": {},
            "summary": {}
        }
        
        for region in ["city", "county"]:
            print(f"\nüåÜ Validating {region.title()} Geometries...")
            
            # Load data
            geometry_data = self.load_geometry_data(region)
            if not geometry_data:
                results[region] = {"error": f"Could not load {region} geometry data"}
                continue
            
            region_results = {}
            
            # 1. Basic data structure validation
            print(f"   üìä Total geometries: {len(geometry_data.get('geometries', {}))}")
            
            # 2. Regional bounds validation
            bounds_validation = self.validate_regional_bounds(geometry_data, region)
            region_results["bounds"] = bounds_validation
            print(f"   üó∫Ô∏è Regional bounds: {bounds_validation['stats']['within_bounds']}/{bounds_validation['stats']['total_geometries']} within expected bounds")
            
            if bounds_validation["issues"]:
                print(f"   ‚ö†Ô∏è Bounds issues: {len(bounds_validation['issues'])} found")
                for issue in bounds_validation["issues"][:3]:
                    print(f"      ‚Ä¢ {issue}")
            
            # 3. Sample geometry validation
            sample_validation = self.validate_sample_geometries(geometry_data, region, 20)
            region_results["sample"] = sample_validation
            print(f"   üî¨ Sample validation: {sample_validation['valid_count']}/{sample_validation['total_sampled']} geometries valid")
            
            if sample_validation["issues"]:
                print(f"   ‚ö†Ô∏è Sample issues found:")
                for issue in sample_validation["issues"][:5]:
                    print(f"      ‚Ä¢ {issue}")
            
            # 4. Calculate overall statistics
            total_points = sum(result["coord_stats"]["total_points"] for result in sample_validation["sample_results"])
            avg_points_per_geometry = total_points / len(sample_validation["sample_results"]) if sample_validation["sample_results"] else 0
            
            region_results["statistics"] = {
                "total_geometries": len(geometry_data.get("geometries", {})),
                "sample_size": sample_validation["total_sampled"],
                "valid_sample_rate": sample_validation["valid_count"] / sample_validation["total_sampled"] if sample_validation["total_sampled"] > 0 else 0,
                "avg_points_per_geometry": round(avg_points_per_geometry, 1)
            }
            
            print(f"   üìà Average points per geometry: {region_results['statistics']['avg_points_per_geometry']}")
            
            results[region] = region_results
        
        # Generate summary
        city_stats = results.get("city", {}).get("statistics", {})
        county_stats = results.get("county", {}).get("statistics", {})
        
        total_geometries = city_stats.get("total_geometries", 0) + county_stats.get("total_geometries", 0)
        city_valid_rate = results.get("city", {}).get("sample", {}).get("valid_count", 0) / max(results.get("city", {}).get("sample", {}).get("total_sampled", 1), 1)
        county_valid_rate = results.get("county", {}).get("sample", {}).get("valid_count", 0) / max(results.get("county", {}).get("sample", {}).get("total_sampled", 1), 1)
        overall_valid_rate = (city_valid_rate + county_valid_rate) / 2
        
        results["summary"] = {
            "total_geometries": total_geometries,
            "overall_validity_rate": round(overall_valid_rate * 100, 1),
            "city_validity_rate": round(city_valid_rate * 100, 1),
            "county_validity_rate": round(county_valid_rate * 100, 1),
            "recommendation": "PASS" if overall_valid_rate > 0.9 else "REVIEW" if overall_valid_rate > 0.7 else "FAIL"
        }
        
        print(f"\nüìä VALIDATION SUMMARY")
        print("=" * 60)
        print(f"Total geometries processed: {total_geometries:,}")
        print(f"Overall validity rate: {results['summary']['overall_validity_rate']}%")
        print(f"City validity rate: {results['summary']['city_validity_rate']}%")
        print(f"County validity rate: {results['summary']['county_validity_rate']}%")
        print(f"Recommendation: {results['summary']['recommendation']}")
        
        if results["summary"]["recommendation"] == "PASS":
            print("‚úÖ Geometry validation PASSED - High quality geometries detected")
        elif results["summary"]["recommendation"] == "REVIEW":
            print("‚ö†Ô∏è Geometry validation needs REVIEW - Some quality issues detected")
        else:
            print("‚ùå Geometry validation FAILED - Significant quality issues detected")
        
        return results

def main():
    """Main entry point for geometry validation"""
    # Set paths
    data_dir = Path("/Users/duebelbytes/Sites/land-estimator/src/data/tmp/raw")
    
    # Initialize validator
    validator = GeometryValidator(data_dir)
    
    # Run validation
    results = validator.run_full_validation()
    
    # Save results
    results_file = data_dir / "geometry_validation_results.json"
    with open(results_file, 'w') as f:
        json.dump(results, f, indent=2)
    
    print(f"\nüíæ Validation results saved to: {results_file}")
    
    return 0 if results["summary"]["recommendation"] != "FAIL" else 1

if __name__ == "__main__":
    exit(main())
